<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Gateway - Servers (Test)</title>
    <!-- Google Font Link (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- End Google Font Link -->
    <link rel="stylesheet" href="{{ url_for('static', path='/style.css') }}">
    <style>
        /* Keyframes for spinner animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* -- Theme Color Variables -- */
        :root {
            --bg-color: #f8f9fa; /* Light background */
            --text-color: #212529; /* Dark text */
            --card-bg: #ffffff; /* White cards */
            --card-border: #dee2e6; /* Keep border color */
            --header-bg: #e9ecef;
            --sidebar-bg: var(--bg-color); /* Match main background */
            --button-bg: #0d6efd; /* Primary button */
            --button-text: #ffffff;
            --secondary-button-bg: #6c757d; /* Gray secondary */
            --secondary-button-text: #ffffff;
            --link-color: #0d6efd;
            --badge-bg: #6c757d;
            --badge-text: #ffffff;
            --official-badge-bg: #0d6efd;
            --official-badge-text: #ffffff;
            --input-bg: #ffffff;
            --input-text: #212529;
            --input-placeholder: #6c757d;
            /* Theme Toggle Button Colors - Light Mode */
            --toggle-button-bg: #ffffff; /* White background */
            --toggle-button-text: #212529; /* Dark icon */
            --toggle-button-border: #dee2e6; /* Light border */
            /* Add more variables as needed */
        }

        html.dark-mode {
            --bg-color: #212529; /* Dark background */
            --text-color: #f8f9fa; /* Light text */
            --card-bg: #343a40; /* Darker cards */
            --card-border: #495057;
            --header-bg: #495057;
            --sidebar-bg: var(--bg-color); /* Match main background */
            --button-bg: #0d6efd; /* Keep primary button */
            --button-text: #ffffff;
            --secondary-button-bg: #6c757d; /* Keep secondary button gray */
            --secondary-button-text: #ffffff;
            --link-color: #6ea8fe; /* Lighter blue link */
            --badge-bg: #adb5bd;
            --badge-text: #212529;
            --official-badge-bg: #6ea8fe; /* Lighter blue official */
            --official-badge-text: #212529; /* Dark text on light blue */
            --input-bg: #495057;
            --input-text: #f8f9fa;
            --input-placeholder: #adb5bd;
            /* Theme Toggle Button Colors - Dark Mode */
            --toggle-button-bg: #495057; /* Dark background (matches header) */
            --toggle-button-text: #f8f9fa; /* Light icon */
            --toggle-button-border: #6c757d; /* Darker border */
        }

        /* Apply variables */
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6; /* Improve readability */
        }
        .main-header {
            background-color: var(--header-bg);
            border-bottom: 1px solid var(--card-border); /* Add subtle border */
            /* Assuming header text color is inherited or set in style.css */
        }
        .sidebar {
             background-color: var(--sidebar-bg);
             color: var(--text-color); /* Ensure sidebar uses main text color */
        }
        .sidebar h3 {
            color: var(--text-color); /* Ensure heading uses text color */
            border-bottom: 1px solid var(--card-border); /* Add separator */
            padding-bottom: 0.5em;
            margin-bottom: 1em;
        }
        .sidebar ul,
        .sidebar ul li,
        .sidebar ul li span,
        .sidebar ul li span:first-child { /* Ensure all sidebar text inherits */
             font-weight: 600; /* Make label slightly bolder */
             color: var(--text-color);
        }
        .sidebar ul li span:last-child {
             /* Assuming the count badge has its own styling */
        }
        .service-card {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            color: var(--text-color); /* Ensure card text uses theme color */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); /* Subtle shadow */
        }
        .service-card h2, .service-card .owner, .service-card .description {
             color: var(--text-color); /* Explicitly set text color */
        }
        /* Example for a specific badge if needed */
        .badge {
            background-color: var(--badge-bg);
            color: var(--badge-text);
        }
        .edit-button {
            /* Assuming style.css defines button styles, override if needed */
            /* background-color: var(--button-bg); */
            /* color: var(--button-text); */
        }
        a {
            color: var(--link-color);
        }
        .toggle-label {
            color: var(--text-color);
        }
        .logout-button,
        .search-bar button {
            background-color: var(--secondary-button-bg);
            color: var(--secondary-button-text);
            border: 1px solid var(--secondary-button-bg);
        }
        .edit-button { /* Assuming this is primary */
            background-color: var(--button-bg);
            color: var(--button-text);
            /* Add padding/border etc. if needed from style.css */
        }
        .search-bar input[type="search"] {
            background-color: var(--input-bg);
            color: var(--input-text);
            border: 1px solid var(--card-border);
        }
        .search-bar input[type="search"]::placeholder {
            color: var(--input-placeholder);
            opacity: 1; /* Override browser defaults */
        }
        .official-badge {
            background-color: var(--official-badge-bg);
            color: var(--official-badge-text);
            padding: 0.2em 0.6em; /* Add padding if it doesn't have it */
            border-radius: 0.8em; /* Add rounding if it doesn't have it */
            font-size: 0.8em;
            font-weight: bold;
            vertical-align: middle;
        }

        /* Health Status Badge Styles */
        .status-badge {
            border-radius: 0.8em;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            vertical-align: middle;
            white-space: nowrap;
            display: inline-block;
            padding: 0.2em 0.6em;
            line-height: 1.4;
            margin-right: 5px;
        }
        .status-healthy {
            background-color: #28a745; /* Green */
        }
        .status-unhealthy {
            background-color: #dc3545; /* Red */
        }
        .status-error {
            background-color: #6c757d; /* Gray */
        }
        .status-disabled {
            background-color: #adb5bd; /* Lighter Gray */
            color: #333;
        }
        .status-unknown {
            background-color: #adb5bd; /* Lighter Gray */
             color: #333;
        }

        /* Style for the separate spinner */
        .status-spinner {
            /* display: none; /* Hidden by default - Let JS control this */
            width: 1.2em;
            height: 1.2em;
            border: 2px solid rgba(253, 126, 20, 0.3); /* Light orange base border */
            border-top-color: #fd7e14; /* Spinner color (Orange) */
            border-radius: 50%;
            vertical-align: middle;
            display: inline-block; /* Keep inline-block for layout when visible */
            animation: spin 1s linear infinite;
            box-sizing: border-box;
            position: relative; /* Allow relative positioning */
            top: -5px; /* Nudge down slightly (adjust as needed) */
        }

        /* Wrapper for badge and spinner */
        .status-indicator-area {
            display: flex;
            align-items: center; /* Back to center alignment */
            margin-bottom: 10px; /* Space below this area */
            /* height: 2em; */ /* Optional: Set a fixed height for the container? */
        }

        /* Adjust header items container */
        .card-header .header-right-items {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* New style for controls row */
        .card-body .controls-row {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Push items to ends */
            gap: 15px; /* Space between items if they were closer */
            margin-top: 15px; /* Add some space above this row */
        }

        /* Ensure toggle form doesn't take extra space */
        .card-body .toggle-form {
            margin: 0; /* Remove default margins if any */
        }

        /* Style for the moved status badge */
        .card-body .status-badge {
            display: inline-block; /* Allow margin */
            margin-bottom: 10px; /* Space below badge */
        }

        /* Ensure main title uses text color */
        .content h1 {
            color: var(--text-color);
        }

        /* --- Theme Toggle Button --- */
        .theme-toggle-button {
            cursor: pointer;
            font-size: 1.1em; /* Make icon smaller */
            background: none; /* Transparent background */
            border: none; /* No border */
            color: var(--text-color); /* Use main text color for icon */
            padding: 0; /* Remove padding */
            margin-left: 10px; /* Add some space */
            position: relative; /* Allow nudging */
            top: -2px; /* Nudge up slightly (adjust px value if needed) */
        }

        /* Ensure header right items are vertically centered */
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px; /* Adjust spacing as needed */
        }

        /* Explicit alignment for non-button items */
        .header-right .user-display {
            vertical-align: middle;
        }

        /* Ensure form aligns correctly in flex context */
        .header-right form {
             margin: 0; /* Remove default form margin */
             padding: 0; /* Remove default form padding */
             display: inline-block; /* Treat form like an inline block */
             vertical-align: middle;
        }

        /* --- Tool List Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: var(--card-bg);
            color: var(--text-color);
            padding: 20px 30px;
            border-radius: 8px;
            min-width: 300px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        .modal-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.8em;
            font-weight: bold;
            color: var(--text-color);
            cursor: pointer;
            line-height: 1;
        }
        .modal-close-button:hover {
            opacity: 0.7;
        }
        #tool-modal-list-container ul {
            list-style: disc;
            padding-left: 20px;
            margin-top: 10px;
        }
        #tool-modal-list-container li {
            margin-bottom: 5px;
        }
        /* --- Style for clickable tool icon --- */
        .clickable-tool-icon {
            cursor: pointer;
            text-decoration: none; /* Remove underline if wrapped in <a> */
        }
        .clickable-tool-icon:hover {
             opacity: 0.8;
        }

        /* --- Sidebar Toggle Styles --- */
        .header-left {
            display: flex;
            align-items: center;
        }
        .sidebar-toggle-button {
            /* Remove absolute positioning styles */
            /* position: absolute; */
            /* top: 10px; */
            /* right: 10px; */
            /* z-index: 10; */
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5em; /* Adjust size */
            cursor: pointer;
            /* Restore original padding/margin */
            padding: 0 10px;
            margin-right: 10px;
        }
        .sidebar-toggle-button:hover {
            opacity: 0.7;
        }

        /* Collapsible Sidebar Styles */
        .sidebar {
            /* Remove relative positioning */
            /* position: relative; */
            width: 250px; /* Standard width */
            transition: width 0.3s ease, padding 0.3s ease;
            overflow-x: hidden; /* Prevent horizontal scrollbar during transition */
            padding: 20px;
            flex-shrink: 0; /* Prevent sidebar from shrinking smaller than width */
        }
        .content {
            flex-grow: 1;
            margin-left: 20px; /* Standard margin */
            transition: margin-left 0.3s ease;
            overflow-y: auto; /* Allow content to scroll independently */
            padding-bottom: 20px; /* Ensure space at bottom */
        }
        /* Styles when collapsed */
        body.sidebar-collapsed .sidebar {
            width: 0; /* Collapse completely */
            padding: 20px 0; /* Collapse padding horizontally */
        }
        body.sidebar-collapsed .content {
            margin-left: 0; /* No margin when sidebar is 0 width */
        }
        /* Hide sidebar content */
        body.sidebar-collapsed .sidebar > * {
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s 0.3s, opacity 0.3s ease; /* Delay hiding until width transition ends */
        }
        /* Make sidebar content visible again when expanded */
        .sidebar > * {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.3s ease 0.1s; /* Fade in slightly delayed */
        }

        /* --- New Sidebar Content Styles --- */
        .sidebar-section {
            margin-bottom: 2em;
        }
        .sidebar-section h3 {
            font-size: 0.9em;
            font-weight: 600;
            color: var(--input-placeholder); /* Use subtle color for heading */
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.8em;
            padding-left: 10px; /* Align with links */
        }
        .sidebar-nav ul,
        .sidebar-stats {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .sidebar-nav li,
        .sidebar-stats li {
            margin-bottom: 0.5em;
        }
        .sidebar-link {
            display: block;
            color: var(--text-color);
            text-decoration: none;
            padding: 8px 10px;
            border-radius: 4px;
            font-size: 0.95em;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .sidebar-link:hover {
            background-color: var(--card-bg); /* Subtle hover */
            color: var(--link-color); /* Highlight on hover */
        }
        .sidebar-link.active-filter {
            background-color: rgba(13, 110, 253, 0.1); /* Light primary background for active */
            color: var(--link-color);
            font-weight: 600;
        }
        .sidebar-stats li {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: var(--text-color);
            padding: 4px 10px;
        }
        .sidebar-stats span:first-child {
            color: var(--input-placeholder); /* Dim label */
        }
        .sidebar-stats span:last-child {
            font-weight: 600;
        }

        /* Refresh button specific styles */
        .refresh-button {
            background: none;
            border: none;
            padding: 0;
            margin: 0 0 0 5px;
            cursor: pointer;
            vertical-align: middle;
            color: inherit;
            font-size: 1em; /* Match icon span */
        }
        .refresh-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
    <script>
        // =====================================================================
        // == Initialization & Configuration
        // =====================================================================

        // Immediately invoked function to apply theme before rendering
        (function() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = savedTheme || (prefersDark ? 'dark' : 'dark'); // Default to dark
            console.log('[HEAD SCRIPT] Determined initial theme:', theme);
            if (theme === 'dark') {
                document.documentElement.classList.add('dark-mode');
            } else {
                document.documentElement.classList.remove('dark-mode');
            }
        })();

        // Global state map (initialized/updated by WebSocket)
        window.currentHealthStatusMap = {};

        // =====================================================================
        // == Utility Functions
        // =====================================================================

        function formatTimeAgoJS(isoString) {
            if (!isoString) return "Never";
            // console.log(`[formatTimeAgoJS] Formatting: ${isoString}`);
            try {
                const dt = new Date(isoString);
                if (isNaN(dt.getTime())) {
                    console.error(`[formatTimeAgoJS] Invalid Date parsed from: ${isoString}`);
                    return "Invalid date";
                }
                const now = new Date();
                const diff = now.getTime() - dt.getTime();
                const seconds = Math.floor(diff / 1000);
                if (seconds < 2) return "Just now";
                if (seconds < 60) return `${seconds}s ago`;
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours}h ago`;
                const days = Math.floor(hours / 24);
                return `${days}d ago`;
            } catch (e) {
                console.error("Error parsing date:", isoString, e);
                return "Invalid date";
            }
        }

        // =====================================================================
        // == Core UI Update Functions
        // =====================================================================

        function updateAllTimestamps() {
            document.querySelectorAll('.metadata[data-timestamp]').forEach(el => {
                const isoString = el.dataset.timestamp;
                const timeAgoEl = el.querySelector('.time-ago');
                if (timeAgoEl) {
                    timeAgoEl.textContent = formatTimeAgoJS(isoString);
                } else {
                    console.error('[updateAllTimestamps] Could not find .time-ago span within', el);
                }
            });
        }

        function updateServiceDisplay(badgeId, spinnerId, lastCheckedId, serviceData) {
            const badge = document.getElementById(badgeId);
            const spinner = document.getElementById(spinnerId);
            const lastCheckedEl = document.getElementById(lastCheckedId);
            const safePath = badgeId.replace('status-badge-', ''); // Used for num_tools and refresh button
            const numToolsId = 'num-tools-' + safePath;
            const numToolsEl = document.getElementById(numToolsId);

            // console.log(`Updating display for ${badgeId}. Data:`, serviceData);

            if (!badge || !spinner || !lastCheckedEl) {
                console.error(`Missing elements for ${badgeId}. Badge: ${!!badge}, Spinner: ${!!spinner}, Timestamp: ${!!lastCheckedEl}`);
                return;
            }
             if (!numToolsEl) {
                console.error(`Missing num_tools element with ID: ${numToolsId}`);
            }

            const status = serviceData.status;
            const lastCheckedIso = serviceData.last_checked_iso;
            const numTools = serviceData.num_tools;

            // --- Update Health Status Display ---
            let statusClass = 'status-unknown';
            let displayText = 'unknown';
            let showSpinner = false;

            if (status === 'healthy') {
                statusClass = 'status-healthy';
                displayText = 'healthy';
            } else if (status.startsWith('unhealthy')) {
                statusClass = 'status-unhealthy';
                displayText = status.includes('(') ? status.split('(')[0].trim() : status;
            } else if (status.startsWith('error')) {
                statusClass = 'status-error';
                displayText = status.includes('(') ? status.split('(')[0].trim() : status;
            } else if (status === 'disabled') {
                statusClass = 'status-disabled';
                displayText = 'disabled';
            } else if (status === 'checking') {
                statusClass = 'status-unknown';
                displayText = 'checking';
                showSpinner = true;
            }

            badge.className = 'status-badge ' + statusClass;
            badge.textContent = displayText;
            badge.title = status; // Tooltip shows full status
            spinner.style.display = showSpinner ? 'inline-block' : 'none';
            // console.log(`[updateServiceDisplay] Status: ${status}, Class: ${statusClass}, Text: ${displayText}, Spinner: ${showSpinner}`);

            // --- Update Last Checked Time ---
            // console.log(`[updateServiceDisplay] Received lastCheckedIso: ${lastCheckedIso} for ${lastCheckedId}`);
            lastCheckedEl.dataset.timestamp = lastCheckedIso || '';
            const timeAgoEl = lastCheckedEl.querySelector('.time-ago');
            if (timeAgoEl) {
                timeAgoEl.textContent = formatTimeAgoJS(lastCheckedIso);
            } else {
                console.error('[updateServiceDisplay] Could not find .time-ago span within', lastCheckedEl);
            }

            // --- Update Num Tools Display ---
            if (numToolsEl && numTools !== undefined && numTools !== null) {
                numToolsEl.textContent = `ðŸ”§ ${numTools}`;
            }

            // --- Update Refresh Button State ---
            try {
                const originalPath = '/' + safePath.replace(/_/g, '/');
                const refreshButton = document.querySelector(`.refresh-button[data-path="${originalPath}"]`);
                if (refreshButton) {
                    const shouldBeDisabled = (status === 'disabled');
                    refreshButton.disabled = shouldBeDisabled;
                    // console.log(`[updateServiceDisplay] Setting refresh button for ${originalPath} disabled state to: ${shouldBeDisabled}`);
                } else {
                    console.warn(`[updateServiceDisplay] Could not find refresh button for path: ${originalPath}`);
                }
            } catch (e) {
                console.error("[updateServiceDisplay] Error finding or updating refresh button state:", e);
            }
        }

        function updateSidebarStats(currentServiceDataMap) {
            // Update the global map used for calculation
            Object.assign(window.currentHealthStatusMap, currentServiceDataMap);

            const statEnabled = document.getElementById('stat-enabled');
            const statDisabled = document.getElementById('stat-disabled');
            const statIssues = document.getElementById('stat-issues');
            const statTotal = document.getElementById('stat-total');

            if (!statEnabled || !statDisabled || !statIssues || !statTotal) {
                console.warn("Sidebar stat elements not found.");
                return;
            }

            let enabledCount = 0;
            let disabledCount = 0;
            let issuesCount = 0;
            const servicePaths = Object.keys(window.currentHealthStatusMap);

            statTotal.textContent = servicePaths.length;

            for (const path of servicePaths) {
                 const statusData = window.currentHealthStatusMap[path];
                 const status = statusData.status;
                 if (status === 'disabled') {
                     disabledCount++;
                 } else {
                     enabledCount++;
                     if (status.startsWith('error') || status.startsWith('unhealthy')) {
                         issuesCount++;
                     }
                 }
            }

            statEnabled.textContent = enabledCount;
            statDisabled.textContent = disabledCount;
            statIssues.textContent = issuesCount;
        }

        // =====================================================================
        // == Card Filtering Logic
        // =====================================================================

        function applyCardFilter(filterType) {
            console.log(`Applying filter: ${filterType}`);
            const cards = document.querySelectorAll('.service-card');
            let visibleCount = 0;

            cards.forEach(card => {
                let shouldShow = false;
                const path = card.querySelector('.refresh-button')?.dataset.path; // Get path from refresh button
                if (!path) {
                    console.warn("Could not find path for card:", card);
                    card.style.display = 'block'; // Show if path unknown
                    visibleCount++;
                    return;
                }
                // Construct badge ID based on path
                const safePath = path.replace(/^\//, '').replace(/\//g, '_').replace(/:/g, '_');
                const badgeId = 'status-badge-' + safePath;
                const badge = document.getElementById(badgeId);
                // Trim the status read from the title for robust comparison
                const currentStatus = badge ? badge.title.trim() : 'unknown';
                console.log(`Card Path: ${path}, Status Read: '${currentStatus}', Filter: ${filterType}`); // Add log

                switch (filterType) {
                    case 'all':
                        shouldShow = true;
                        break;
                    case 'enabled':
                        shouldShow = (currentStatus !== 'disabled');
                        break;
                    case 'disabled':
                        shouldShow = (currentStatus === 'disabled');
                        break;
                    case 'issues':
                        shouldShow = currentStatus.startsWith('error') || currentStatus.startsWith('unhealthy');
                        break;
                    default:
                        shouldShow = true; // Default to showing if filter unknown
                }

                card.style.display = shouldShow ? 'block' : 'none';
                if (shouldShow) {
                    visibleCount++;
                }
            });
            console.log(`Filter applied. Visible cards: ${visibleCount}`);
            // TODO: Update a "no results" message visibility if needed
        }

        // =====================================================================
        // == Modal Logic
        // =====================================================================

        async function showToolModal(servicePath, serviceName) {
            const toolModal = document.getElementById('tool-modal');
            const toolModalTitle = document.getElementById('tool-modal-title');
            const toolModalListContainer = document.getElementById('tool-modal-list-container');

            if (!toolModal || !toolModalTitle || !toolModalListContainer) {
                console.error("Tool modal elements not found!"); return;
            }

            toolModalTitle.textContent = `Tools for ${serviceName}`;
            toolModalListContainer.innerHTML = '<p>Loading...</p>';
            toolModal.style.display = 'flex';

            try {
                const apiPath = servicePath.startsWith('/') ? servicePath : '/' + servicePath;
                const response = await fetch(`/api/tools${apiPath}`);
                toolModalListContainer.innerHTML = ''; // Clear loading

                if (!response.ok) {
                    let errorMsg = `Error fetching tools: ${response.status} ${response.statusText}`;
                    try { const errorData = await response.json(); errorMsg = errorData.detail || errorMsg; } catch(e) {}
                    throw new Error(errorMsg);
                }

                const data = await response.json();
                const tools = data.tools;

                if (tools && tools.length > 0) {
                    tools.forEach(tool => {
                        const toolDiv = document.createElement('div');
                        toolDiv.style.marginBottom = '15px';
                        toolDiv.style.borderBottom = '1px solid var(--card-border)';
                        toolDiv.style.paddingBottom = '10px';

                        const nameEl = document.createElement('h4');
                        nameEl.textContent = tool.name || 'Unnamed Tool';
                        nameEl.style.marginTop = '0'; nameEl.style.marginBottom = '5px';
                        toolDiv.appendChild(nameEl);

                        // Render Parsed Description
                        if (tool.parsed_description) {
                            const mainDescEl = document.createElement('p');
                            mainDescEl.textContent = tool.parsed_description.main || 'No description available.';
                            mainDescEl.style.whiteSpace = 'pre-wrap';
                            toolDiv.appendChild(mainDescEl);

                            const renderSection = (title, content) => {
                                if (!content) return;
                                const titleEl = document.createElement('strong');
                                titleEl.textContent = title + ':';
                                titleEl.style.display = 'block'; titleEl.style.marginTop = '8px';
                                toolDiv.appendChild(titleEl);
                                const preEl = document.createElement('pre');
                                preEl.textContent = content;
                                preEl.style.marginLeft = '10px'; preEl.style.marginTop = '3px';
                                preEl.style.whiteSpace = 'pre-wrap'; preEl.style.fontSize = '0.9em';
                                toolDiv.appendChild(preEl);
                            };
                            renderSection('Args', tool.parsed_description.args);
                            renderSection('Returns', tool.parsed_description.returns);
                            renderSection('Raises', tool.parsed_description.raises);

                        } else if (tool.description) { // Fallback
                            const descEl = document.createElement('p');
                            descEl.textContent = tool.description;
                            descEl.style.marginBottom = '8px';
                            toolDiv.appendChild(descEl);
                        }

                        // Render Schema
                        if (tool.schema && typeof tool.schema === 'object' && Object.keys(tool.schema).length > 0) {
                            const schemaContainer = document.createElement('div');
                            schemaContainer.style.marginTop = '10px';
                            schemaContainer.innerHTML = '<strong>Input Schema:</strong>';

                            const properties = tool.schema.properties;
                            const required = tool.schema.required || [];

                            if (properties && typeof properties === 'object' && Object.keys(properties).length > 0) {
                                const propsList = document.createElement('div');
                                propsList.style.marginLeft = '15px'; propsList.style.marginTop = '5px';
                                propsList.style.borderLeft = '2px solid var(--card-border)'; propsList.style.paddingLeft = '10px';

                                for (const [propName, propDetails] of Object.entries(properties)) {
                                    const propDiv = document.createElement('div');
                                    propDiv.style.marginBottom = '8px';

                                    const nameSpan = document.createElement('strong');
                                    nameSpan.textContent = propName;
                                    propDiv.appendChild(nameSpan);

                                    if (required.includes(propName)) {
                                        const reqSpan = document.createElement('span');
                                        reqSpan.textContent = ' (required)'; reqSpan.style.color = '#dc3545';
                                        reqSpan.style.fontSize = '0.8em'; reqSpan.style.marginLeft = '3px';
                                        propDiv.appendChild(reqSpan);
                                    }
                                    if (propDetails.type) {
                                        const typeSpan = document.createElement('span');
                                        typeSpan.textContent = ` - Type: ${propDetails.type}`;
                                        typeSpan.style.color = 'var(--input-placeholder)'; typeSpan.style.marginLeft = '5px';
                                        propDiv.appendChild(typeSpan);
                                    }
                                    if (propDetails.description) {
                                        const descP = document.createElement('p');
                                        descP.textContent = propDetails.description;
                                        descP.style.margin = '3px 0 0 10px'; descP.style.fontSize = '0.85em';
                                        propDiv.appendChild(descP);
                                    }
                                    if (propDetails.default !== undefined) {
                                        const defaultP = document.createElement('p');
                                        defaultP.textContent = `Default: ${JSON.stringify(propDetails.default)}`;
                                        defaultP.style.margin = '3px 0 0 10px'; defaultP.style.fontSize = '0.85em';
                                        defaultP.style.color = 'var(--input-placeholder)';
                                        propDiv.appendChild(defaultP);
                                    }
                                    propsList.appendChild(propDiv);
                                }
                                schemaContainer.appendChild(propsList);
                            } else {
                                schemaContainer.innerHTML += '<p style="margin-left: 15px; font-style: italic;">No input parameters defined.</p>';
                            }
                            // Optionally display $defs notice
                            if (tool.schema.$defs && Object.keys(tool.schema.$defs).length > 0) {
                                schemaContainer.innerHTML += '<p style="margin-top: 10px; font-size: 0.8em; color: var(--input-placeholder);"><strong>Definitions:</strong> (Schema uses shared definitions not fully displayed here)</p>';
                            }
                            toolDiv.appendChild(schemaContainer);
                        } else if (tool.schema && Object.keys(tool.schema).length === 0){
                             toolDiv.innerHTML += '<p style="margin-top: 10px; font-style: italic;"><strong>Input Schema:</strong> No parameters defined.</p>';
                        }
                        toolModalListContainer.appendChild(toolDiv);
                    });
                } else {
                    toolModalListContainer.innerHTML = '<p>No tools listed for this service.</p>';
                }
            } catch (error) {
                console.error("Failed to fetch or display tools:", error);
                toolModalListContainer.innerHTML = `<p style="color: red;">Could not load tools: ${error.message}</p>`;
            }
        }

        function closeToolModal() {
            const toolModal = document.getElementById('tool-modal');
            const toolModalListContainer = document.getElementById('tool-modal-list-container');
            if (toolModal) {
                toolModal.style.display = 'none';
                if (toolModalListContainer) {
                    toolModalListContainer.innerHTML = ''; // Clear content
                }
            }
        }

        // =====================================================================
        // == WebSocket Logic
        // =====================================================================

        let ws = null;
        let reconnectInterval = 5000; // Start with 5 seconds

        function connectWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws/health_status`;
            console.log(`Attempting to connect WebSocket to ${wsUrl}...`);

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log("WebSocket connection established.");
                reconnectInterval = 5000; // Reset reconnect interval on successful connection
            };

            ws.onmessage = (event) => {
                // console.log("WebSocket message received:", event.data);
                try {
                    const data = JSON.parse(event.data);
                    // console.log("Parsed WebSocket data:", data);

                    // Update displays for each service in the message
                    for (const path in data) {
                        if (data.hasOwnProperty(path)) {
                            const serviceData = data[path];
                            // Construct IDs - Ensure consistent path normalization (replace / and :)
                            const safePath = path.replace(/^\//, '').replace(/\//g, '_').replace(/:/g, '_');
                            const badgeId = 'status-badge-' + safePath;
                            const spinnerId = 'spinner-for-' + safePath;
                            const lastCheckedId = 'last-checked-' + safePath;

                            updateServiceDisplay(badgeId, spinnerId, lastCheckedId, serviceData);
                        }
                    }
                     // Update sidebar stats after processing the message
                     updateSidebarStats(data);

                } catch (error) {
                    console.error("Error parsing WebSocket message or updating UI:", error);
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket error:", error);
                // Error event likely followed by close event, rely on close for reconnect logic
            };

            ws.onclose = (event) => {
                console.log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}. Attempting to reconnect in ${reconnectInterval / 1000}s...`);
                ws = null; // Ensure ws variable is nullified
                setTimeout(connectWebSocket, reconnectInterval);
                // Optional: Exponential backoff
                // reconnectInterval = Math.min(reconnectInterval * 2, 60000); // Double interval up to 60s
            };
        }

        // =====================================================================
        // == Event Handlers
        // =====================================================================

        function handleToggleClick(checkboxElement, servicePath) {
             console.log(`Toggle clicked for path: ${servicePath}`);
             const safePath = servicePath.replace(/\//g, '_').replace(/:/g, '_');
             const spinnerId = 'spinner-for-' + safePath;
             const spinner = document.getElementById(spinnerId);
             if (spinner) {
                 spinner.style.display = 'inline-block'; // Show spinner immediately
             } else {
                 console.warn(`Spinner element not found for ID: ${spinnerId}`);
             }
             checkboxElement.form.submit(); // Submit the form
        }

        async function handleRefreshClick(event) {
            const refreshButton = event.target.closest('.refresh-button');
            if (!refreshButton || refreshButton.disabled) {
                return; // Ignore clicks not on an enabled refresh button
            }

            event.preventDefault(); // Prevent any default button action if needed

            const servicePath = refreshButton.dataset.path;
            if (!servicePath) {
                console.error("Refresh button missing data-path attribute.");
                return;
            }
            console.log(`Refresh button clicked for path: ${servicePath}`);

            // Indicate loading state
            refreshButton.disabled = true;
            const originalIconHTML = refreshButton.innerHTML;
            // Use a simple spinner for loading feedback
            refreshButton.innerHTML = '<span class="status-spinner" style="width: 0.9em; height: 0.9em; border-width: 2px; top: 0;"></span>';

            try {
                const response = await fetch(`/api/refresh${servicePath}`, { method: 'POST' });

                if (!response.ok) {
                    let errorMsg = `Error refreshing: ${response.status} ${response.statusText}`;
                    try { const errorData = await response.json(); errorMsg = errorData.detail || errorMsg; } catch(e) {}
                    throw new Error(errorMsg);
                }

                const result = await response.json();
                console.log(`Refresh successful for ${servicePath}:`, result);
                // UI update is handled by the WebSocket push triggered by the backend.

            } catch (error) {
                console.error(`Failed to trigger refresh for ${servicePath}:`, error);
                alert(`Could not refresh service ${servicePath}: ${error.message}`);
            } finally {
                // Restore button state after a short delay to allow WS update if needed
                setTimeout(() => {
                    // Check if still disabled before re-enabling (WS might have disabled it)
                    if (refreshButton.disabled) {
                       // We might not always want to re-enable it here if the refresh failed
                       // and the status remains error/disabled via WS.
                       // Let's trust the WS update from updateServiceDisplay for the final disabled state.
                       // Just restore the icon.
                    }
                    refreshButton.innerHTML = originalIconHTML;
                    // Re-enable *only if* the WS didn't disable it.
                    // Find the current status from the badge title to decide.
                    const badgeId = 'status-badge-' + servicePath.replace(/^\//, '').replace(/\//g, '_').replace(/:/g, '_');
                    const badge = document.getElementById(badgeId);
                    if (badge && badge.title !== 'disabled') {
                         refreshButton.disabled = false;
                    }

                }, 300); // Small delay
            }
        }


        function handleThemeToggle() {
            const htmlElement = document.documentElement;
            const isDarkMode = htmlElement.classList.toggle('dark-mode');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            console.log('Theme toggled to:', isDarkMode ? 'dark' : 'light');
            // Update button icon if needed (e.g., sun/moon) - requires icon elements
            const themeToggleButton = document.getElementById('theme-toggle');
            if (themeToggleButton) {
                themeToggleButton.textContent = isDarkMode ? 'â˜€ï¸' : 'ðŸŒ™'; // Example icon change
            }
        }

        function handleSidebarToggle() {
            const bodyElement = document.body;
            const isCollapsed = bodyElement.classList.toggle('sidebar-collapsed');
            localStorage.setItem('sidebarCollapsed', isCollapsed);
            console.log(`Sidebar toggled. Collapsed: ${isCollapsed}`);
        }

        function handleModalOverlayClick(event) {
            if (event.target === document.getElementById('tool-modal')) {
                closeToolModal();
            }
        }

        function handleFilterClick(event) {
            const link = event.target.closest('.sidebar-link[data-filter]');
            if (!link) return; // Ignore clicks outside filter links

            event.preventDefault(); // Stop browser navigation

            const filterType = link.dataset.filter;
            console.log("Filter link clicked:", filterType);

            // Update active link style
            document.querySelectorAll('.sidebar-nav .sidebar-link').forEach(l => {
                l.classList.remove('active-filter');
            });
            link.classList.add('active-filter');

            // Apply the filter to cards
            applyCardFilter(filterType);
        }

        // =====================================================================
        // == DOMContentLoaded Initializer
        // =====================================================================

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed.");

            // Initial UI setup
            updateAllTimestamps(); // Format initial timestamps

            // Start WebSocket connection
            connectWebSocket(); // Handles ongoing UI updates

            // Attach Event Listeners
            const themeToggleButton = document.getElementById('theme-toggle');
            if (themeToggleButton) {
                 // Set initial icon based on loaded theme
                 themeToggleButton.textContent = document.documentElement.classList.contains('dark-mode') ? 'â˜€ï¸' : 'ðŸŒ™';
                 themeToggleButton.addEventListener('click', handleThemeToggle);
            }

            const sidebarToggleButton = document.getElementById('sidebar-toggle');
             if (sidebarToggleButton) {
                // Check local storage for initial sidebar state
                if (localStorage.getItem('sidebarCollapsed') === 'true') {
                    document.body.classList.add('sidebar-collapsed');
                }
                 sidebarToggleButton.addEventListener('click', handleSidebarToggle);
             }

            const toolModalOverlay = document.getElementById('tool-modal');
            if (toolModalOverlay) {
                toolModalOverlay.addEventListener('click', handleModalOverlayClick);
            }

             // Delegated event listener for refresh buttons
             document.addEventListener('click', handleRefreshClick);

             // Delegated event listener for sidebar filter links
             const sidebarNav = document.querySelector('.sidebar-nav');
             if (sidebarNav) {
                 sidebarNav.addEventListener('click', handleFilterClick);
             }

             // Apply initial filter state
             applyCardFilter('all'); // Show all cards initially

             // Initialize sidebar stats based on initial page render
             // Build initial map from rendered data (less efficient, but works before WS)
             const initialStatusMap = {};
             document.querySelectorAll('.service-card').forEach(card => {
                 const path = card.querySelector('.refresh-button')?.dataset.path;
                 const badge = card.querySelector('.status-badge');
                 if(path && badge) {
                     initialStatusMap[path] = { status: badge.title, num_tools: 0 }; // num_tools unknown here
                 }
             });
             updateSidebarStats(initialStatusMap);

             // Note: Toggle change handler is attached inline via onchange="handleToggleClick(...)"
             // Note: Tool modal click handler is attached inline via onclick="showToolModal(...)"
        });

    </script>
</head>
<body>
    <!-- Main Header -->
    <header class="main-header">
        <div class="header-left">
             {# Button Moved Back To Header #}
             <button id="sidebar-toggle" class="sidebar-toggle-button" title="Toggle Sidebar">â˜°</button>
            <div class="logo">
                <img src="{{ url_for('static', path='/logo.png') }}" alt="MCP Gateway Logo" height="30"> <!-- Logo Image -->
                <span>MCP Gateway</span>
            </div>
        </div>
        <div class="header-right">
            <button id="theme-toggle" class="theme-toggle-button" title="Toggle Theme">ðŸŒ™</button>
            <span class="user-display">User: {{ username }}</span>
            <form action="/logout" method="post" style="display: inline;">
                <button type="submit" class="logout-button">Logout</button>
            </form>
        </div>
    </header>

    <!-- Main Container (Sidebar + Content) -->
    <div class="container" id="main-container">
        <!-- Sidebar (Simplified) -->
        <aside class="sidebar" id="sidebar">
            {# Button Moved Inside Sidebar #}
            {# <button id="sidebar-toggle" class="sidebar-toggle-button" title="Toggle Sidebar">â˜°</button> #}

            {# --- New Sidebar Content --- START #}
            <div class="sidebar-section">
                <h3>Filters</h3>
                <nav class="sidebar-nav">
                    <ul>
                        <li><a href="/" class="sidebar-link active-filter" data-filter="all">All Servers</a></li>
                        <li><a href="#" class="sidebar-link" data-filter="enabled">Enabled</a></li>
                        <li><a href="#" class="sidebar-link" data-filter="disabled">Disabled</a></li>
                        <li><a href="#" class="sidebar-link" data-filter="issues">With Issues</a></li>
                        {# Add more filters later, e.g., by tag #}
                    </ul>
                </nav>
            </div>

            <div class="sidebar-section">
                 <h3>Statistics</h3>
                 <ul class="sidebar-stats">
                     {# These counts need to be calculated/updated via JS or passed from backend #}
                     <li><span>Total Servers:</span> <span id="stat-total">{{ services | length }}</span></li>
                     <li><span>Enabled:</span> <span id="stat-enabled">?</span></li>
                     <li><span>Disabled:</span> <span id="stat-disabled">?</span></li>
                     <li><span>With Issues:</span> <span id="stat-issues">?</span></li>
                 </ul>
            </div>
            {# --- New Sidebar Content --- END #}

            {# Remove old Status section #}
            {#
            <h3>Status</h3>
             <ul>
                 <li><span>Discovered</span> <span>{{ services | length }}</span></li>
             </ul>
             #}
        </aside>

        <!-- Main Content Area -->
        <main class="content">
            <!-- Page Header Section (Simplified) -->
            <div class="page-header">
                 <h1>MCP Servers</h1>
                <!-- Removed breadcrumbs, description, social icons -->
            </div>

            <!-- Controls Section (Simplified) -->
            <div class="controls-area search-controls">
                <!-- Search Form -->
                <form action="/" method="get" class="search-bar">
                    <input type="search" name="query" placeholder="Search by name or description..." value="{{ request.query_params.get('query', '') }}">
                    <button type="submit">Search</button>
                </form>
            </div>

             <!-- Service Cards Section -->
            <div class="card-container">
                {% if services %}
                    {% for service in services %}
                    <div class="service-card">
                        <div class="card-header">
                            <h2>{{ service.display_name }}</h2>
                            <div class="header-right-items">
                                <span class="official-badge">official</span>
                                <span class="icons">
                                    â˜ï¸ ðŸ’»
                                    {# Wrap the refresh icon in a button #}
                                    <button class="refresh-button icon-button"
                                            title="Refresh Status & Tools"
                                            data-path="{{ service.path }}"
                                            style="background: none; border: none; padding: 0; margin: 0 0 0 5px; vertical-align: middle; color: inherit;"
                                            {% if not service.is_enabled %}disabled{% endif %}>
                                        <span class="refresh-icon" style="font-size: 1em;">ðŸ”„</span>
                                        {# Tooltip or accessible text can be added #}
                                    </button>
                                </span>
                            </div>
                        </div>
                        <div class="card-body">
                            <p class="owner">Path: {{ service.path }}</p>
                            <div class="badges">
                                {% for tag in service.tags %}
                                <span class="badge">{{ tag }}</span>
                                {% endfor %}
                            </div>
                            <p class="description">
                                {{ service.description | default('No description provided.') }}
                            </p>

                            {# --- Moved Status Badge Logic Here --- #}
                            {% set initial_status = service.health_status %}
                            {# Determine initial class and text, avoiding 'checking' text #}
                            {% set status_class = 'status-unknown' %}
                            {% set display_text = 'unknown' %}

                            {% if initial_status == 'healthy' %}
                                {% set status_class = 'status-healthy' %}
                                {% set display_text = 'healthy' %}
                            {% elif initial_status.startswith('unhealthy') %}
                                {% set status_class = 'status-unhealthy' %}
                                {% set display_text = initial_status.split('(')[0].strip() %}
                            {% elif initial_status.startswith('error') %}
                                {% set status_class = 'status-error' %}
                                {% set display_text = initial_status.split('(')[0].strip() %}
                            {% elif initial_status == 'disabled' %}
                                {% set status_class = 'status-disabled' %}
                                {% set display_text = 'disabled' %}
                            {% elif initial_status == 'checking' %}
                                {# If checking initially, display as 'unknown' until first WS update #}
                                {# Spinner will be shown by JS if needed #}
                                {% set status_class = 'status-unknown' %}
                                {% set display_text = 'unknown' %}
                            {% endif %}

                            {# Generate IDs - REMOVE leading slash BEFORE replacing #}
                            {% set safe_path = service.path | replace('/', '', 1) | replace('/', '_') | replace(':', '_') %}
                            {% set badge_id = 'status-badge-' + safe_path %}
                            {% set spinner_id = 'spinner-for-' + safe_path %}
                            {% set last_checked_id = 'last-checked-' + safe_path %}

                            {# Render badge with determined initial text/class #}
                            <div class="status-indicator-area">
                                <span id="{{ badge_id }}" class="status-badge {{ status_class }}" title="{{ initial_status }}">{{ display_text }}</span>
                                {# Always render spinner, hide initially with inline style #}
                                <span id="{{ spinner_id }}" class="status-spinner" style="display: none;"></span>
                            </div>

                            <div class="controls-row">
                                <a href="/edit{{ service.path }}" class="edit-button">Modify</a>
                                <form action="/toggle{{ service.path }}" method="post" class="toggle-form">
                                    <label class="switch">
                                        {# Call new JS function on change #}
                                        <input type="checkbox" name="enabled" value="on" {% if service.is_enabled %}checked{% endif %} onchange="handleToggleClick(this, '{{ service.path }}')">
                                        <span class="slider round"></span>
                                    </label>
                                    <span class="toggle-label">{{ 'Enabled' if service.is_enabled else 'Disabled' }}</span>
                                </form>

                            </div>
                        </div>
                        <div class="card-footer">
                            {% set last_checked_id = 'last-checked-' + service.path | replace('/', '_') | replace(':', '_') %}
                            {# Store ISO timestamp, display initial formatted text inside span #}
                            <span id="{{ last_checked_id }}" class="metadata" data-timestamp="{{ service.last_checked_iso or '' }}">
                                ðŸ•’ Last checked: <span class="time-ago">Never</span>
                            </span>
                            {% set num_tools_id = 'num-tools-' + service.path | replace('/', '_') | replace(':', '_') %}
                            <span id="{{ num_tools_id }}" class="metadata clickable-tool-icon" onclick="showToolModal('{{ service.path }}', '{{ service.display_name }}')" title="Click to view tools">ðŸ”§ {{ service.num_tools }}</span>
                            <span class="metadata">â­ {{ service.num_stars }}</span>
                            <div class="platform-icons">
                                 {% if service.is_python %}<span>ðŸ Python</span>{% endif %}
                                 <span>âš–ï¸ {{ service.license }}</span>
                                 <!-- Consider adding OS icons dynamically if needed -->
                                 <span>ðŸ§</span> <span>ï£¿</span> <span>ðŸªŸ</span>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                    <p>No services found matching your query, or none registered. Try rescanning.</p>
                {% endif %}
            </div> <!-- end card-container -->

        </main> <!-- end content -->
    </div> <!-- end container -->

    <!-- Tool List Modal -->
    <div id="tool-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <span class="modal-close-button" onclick="closeToolModal()">&times;</span>
            <h3 id="tool-modal-title">Tools for Service</h3>
            <div id="tool-modal-list-container">
                <!-- Tool list will be populated here by JS -->
                <p>Loading...</p>
            </div>
        </div>
    </div>
    <!-- End Tool List Modal -->

    <script>
        // Moved DOMContentLoaded listener to the end of the script block
        document.addEventListener('DOMContentLoaded', () => {
            // Ensure all functions above are defined before calling them
            connectWebSocket();
            updateAllTimestamps(); // Initial format based on Jinja render
            // setInterval(updateAllTimestamps, 5000); // Keep this commented out for now
        });
    </script>

    <!-- Add Theme Toggle Script -->
</body>
</html>